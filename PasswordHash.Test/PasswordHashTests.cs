// ************************************************************************************************************************************************************
// <copyright file="PasswordHashFixture.cs" company="Thomas Weller Software-Entwicklung">
//  Copyright (c) 2014, Thomas Weller Software-Entwicklung. All rights reserved.
// </copyright>
// <authors>
//   <author>Thomas Weller</author>
// </authors>
// <license name="Creative Commons Attribution-Share Alike 3.0 Unported License" url="http://creativecommons.org/licenses/by-sa/3.0/" />
// <Description>
//    NUnit tests for the PasswordHash class.    
// </Description>
// <auto-generated reason="Prevent StyleCop analysis." />
// ************************************************************************************************************************************************************

using System;
using System.Collections.Generic;
using System.Linq;
using Xunit;
using Xunit.Extensions;

namespace PasswordHash.Test
{
    [Trait("Remark", "While these tests certainly prove nothing in a strict scientifical " +
                     "sense, they reasonably verify that the code works as intended.")]
    public class PasswordHashTests
    {
        [Fact]
        public void SaltIsRandom()
        {
            const int numberOfSalts = 1000;

            var salts = new List<byte[]>(numberOfSalts);

            for (int i = 0; i < numberOfSalts; i++)
            {
                salts.Add(PasswordHash.CreateRandomSalt());
            }

            // assert that each element is unique
            Assert.True(salts.Count == salts.Distinct().Count());
        }

        [Theory]
        [InlineData("test")]
        [InlineData("B4y^KYsa")]
        public void HashIsUnique(string password)
        {
            const int numberOfHashes = 100;

            var hashes = new List<string>(numberOfHashes);

            for (int i = 0; i < numberOfHashes; i++)
            {
                string hash = PasswordHash.CreateHash(password);
                hashes.Add(hash);

                //Console.WriteLine(hash);
            }

            Assert.True(hashes.Count == hashes.Distinct().Count());
        }

        [Theory]
        [InlineData("test")]
        [InlineData("B4y^KYsa")]
        public void CanValidatePasswordAgainstDifferntHashes(string password)
        {
            string hash1 = PasswordHash.CreateHash(password);
            string hash2 = PasswordHash.CreateHash(password);

            Assert.NotEqual(hash1, hash2);
            Assert.True(PasswordHash.ValidatePassword(password, hash1));
            Assert.True(PasswordHash.ValidatePassword(password, hash2));
        }

        [Theory]
        [InlineData(66, 55, 750, "test")]
        [InlineData(128, 121, 1500, "B4y^KYsa")]
        public void CanValidateAnyHashWithStandardSettings(int saltSize, int hashSize, int iterations, string password)
        {
            // set hash creation values, then create hash
            PasswordHash.SaltByteSize = saltSize;
            PasswordHash.HashByteSize = hashSize;
            PasswordHash.Pbkdf2Iterations = iterations;

            string hash = PasswordHash.CreateHash(password);
            Console.WriteLine("Hash for '{0}': {1}", password, hash);

            // now set defaults and assert that the hash validates anyway
            PasswordHash.SetDefaults();

            Assert.True(PasswordHash.ValidatePassword(password, hash));
        }

        [Fact]
        public void CanValidateAnyHashWithAnySettings()
        {
            const string password = "blah123XY";

            // set hash creation values, then create hash
            PasswordHash.SaltByteSize = 75;
            PasswordHash.HashByteSize = 48;
            PasswordHash.Pbkdf2Iterations = 1500;

            string hash = PasswordHash.CreateHash(password);

            // now set different values
            PasswordHash.SaltByteSize = 122;
            PasswordHash.HashByteSize = 99;
            PasswordHash.Pbkdf2Iterations = 500;

            // assert that the hash validates anyway
            Assert.True(PasswordHash.ValidatePassword(password, hash));
        }

        [Theory]
        [InlineData(87, 49, 555, "123456Abc")]
        [InlineData(40, 42, 1999, "Z&f*6!E2")]
        public void CanValidateHashFromStandardSettingsWithAnySettings(int saltSize, int hashSize, int iterations, string password)
        {
            // first  set defaults and create hash
            PasswordHash.SetDefaults();

            string hash = PasswordHash.CreateHash(password);
            Console.WriteLine("Hash for '{0}': {1}", password, hash);

            // now set parameter values and assert that the hash validates anyway
            PasswordHash.SaltByteSize = saltSize;
            PasswordHash.HashByteSize = hashSize;
            PasswordHash.Pbkdf2Iterations = iterations;

            Assert.True(PasswordHash.ValidatePassword(password, hash));
        }
    }
}
