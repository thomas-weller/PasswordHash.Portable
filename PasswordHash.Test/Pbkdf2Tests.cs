// ************************************************************************************************************************************************************
// <copyright file="Pbkdf2Fixture.cs" company="Thomas Weller Software-Entwicklung">
//  Copyright (c) 2014, Thomas Weller Software-Entwicklung. All rights reserved.
// </copyright>
// <authors>
//   <author>Thomas Weller</author>
// </authors>
// <license name="Creative Commons Attribution-Share Alike 3.0 Unported License" url="http://creativecommons.org/licenses/by-sa/3.0/" />
// <Description>
//    xUnit.Net tests for the Pbkdf2 class. Implements the Pbkdf2 test vectors given here: http://tools.ietf.org/html/draft-josefsson-pbkdf2-test-vectors-00.     
//    Note that these tests are marked 'explicit', because they (at least some of them) take quite a long time.
// </Description>
// <auto-generated reason="Prevent StyleCop analysis." />
// ************************************************************************************************************************************************************

using System.Collections.Generic;
using System.Text;
using Xunit;
using Xunit.Extensions;

namespace PasswordHash.Test
{
    public class Pbkdf2Tests
    {
        [Theory(Skip = "Takes very long. (Run only to verify Pbkdf2 implementation).")]
        [InlineData("password", "salt", 1, 20, "0c 60 c8 0f 96 1f 0e 71 f3 a9 b5 24 af 60 12 06 2f e0 37 a6")]
        [InlineData("password", "salt", 2, 20, "ea 6c 01 4d c7 2d 6f 8c cd 1e d9 2a ce 1d 41 f0 d8 de 89 57")]
        [InlineData("password", "salt", 4096, 20, "4b 00 79 01 b7 65 48 9a be ad 49 d9 26 f7 21 d0 65 a4 29 c1")]
        [InlineData("password", "salt", 16777216, 20, "ee fe 3d 61 cd 4d a4 e4 e9 94 5b 3d 6b a2 15 8c 26 34 e9 84")]
        public void TestVector(string password, string salt, int c, int dkLen, string expectedHash)
        {
            byte[] hash = new Pbkdf2().GenerateDerivedKey(
                dkLen, 
                Encoding.UTF8.GetBytes(password), 
                Encoding.UTF8.GetBytes(salt), 
                c);
            string actualHash = CreateLowercaseOctetRepresentation(hash);

            Assert.Equal(expectedHash, actualHash);

        }

        private static string CreateLowercaseOctetRepresentation(IEnumerable<byte> bytes)
        {
            var stringBuilder = new StringBuilder();

            foreach (byte b in bytes)
            {
                stringBuilder.AppendFormat(" {0:X02}", b);
            }

            return stringBuilder.ToString()
                                .Substring(1)
                                .ToLowerInvariant();
        }
    }
}
